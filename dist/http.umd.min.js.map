{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap af69866e159fcf8c84b9","webpack:///./src/uri/encode.ts","webpack:///./src/xhr/headers.ts","webpack:///./src/xhr/response.ts","webpack:///./src/xhr/client.ts","webpack:///./src/index.ts"],"names":[],"mappings":"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","file":"http.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Http\"] = factory();\n\telse\n\t\troot[\"Http\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap af69866e159fcf8c84b9","export type Primitives = string | number | boolean\nexport type PrimitiveArray = string[] | number[] | boolean[]\nexport type QueryObject = { [index: string]: Primitives | PrimitiveArray }\n\nfunction encodeKeyValue(k: string, v: Primitives | PrimitiveArray): string {\n  k = encodeURIComponent(k)\n  if (v === void 0) {\n    return \"\"\n  }\n  if (Array.isArray(v)) {\n    return (v as any[]).map(x => `${k}[]=${encodeURIComponent(x.toString())}`).join(\"&\")\n  }\n  return `${k}=${encodeURIComponent(v.toString())}`\n}\n\nexport function encodeQueryObj(query: QueryObject): string {\n  const q = []\n  for (const key of Object.keys(query)) {\n    q.push(encodeKeyValue(key, query[key]))\n  }\n  return q.join(\"&\")\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/uri/encode.ts","export type Dictionary<T> = { [key: string]: T }\n\nconst ignoreDupeMap: Dictionary<boolean> = {\n  age: true,\n  authorization: true,\n  \"content-length\": true,\n  \"content-type\": true,\n  etag: true,\n  expires: true,\n  from: true,\n  host: true,\n  \"if-modified-since\": true,\n  \"if-unmodified-since\": true,\n  \"last-modified\": true,\n  location: true,\n  \"max-forwards\": true,\n  \"proxy-authorization\": true,\n  referer: true,\n  \"retry-after\": true,\n  \"user-agent\": true\n}\n\n/**\n * Removes all leading and trailing white space characters.\n */\nfunction trim(str: string): string {\n  return str.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\")\n}\n\n/**\n * Parse headers into an object.\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n */\nexport function parseHeaders(headers: string): object {\n  if (!headers) {\n    return {}\n  }\n\n  const parsed: { [key: string]: any } = {}\n  let key: string\n  let val: string\n  let i: number\n\n  for (const line of headers.split(\"\\n\")) {\n    i = line.indexOf(\":\")\n    key = trim(line.substr(0, i)).toLowerCase()\n    val = trim(line.substr(i + 1))\n\n    // Skip empty keys and defined items in the ignore list.\n    if (!key || (parsed.hasOwnProperty(key) && ignoreDupeMap[key])) {\n      continue\n    }\n    if (key === \"set-cookie\") {\n      if (!parsed.hasOwnProperty(key)) {\n        parsed[key] = []\n      }\n      parsed[key] = parsed[key].concat([val])\n      continue\n    }\n\n    parsed[key] = parsed[key] ? parsed[key] + \", \" + val : val\n  }\n\n  return parsed\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr/headers.ts","export class Response {\n  public data: any\n  public status: number\n  public statusText:string\n  public headers: object\n  public xhr: XMLHttpRequest\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr/response.ts","import { encodeQueryObj, QueryObject } from \"../uri/encode\"\nimport { parseHeaders } from \"./headers\"\nimport { Response } from \"./response\"\n\nexport interface RequestOptions {\n  query?: QueryObject\n  data?: RequestData\n  headers?: { [key: string]: string }\n  responseType?: XMLHttpRequestResponseType\n  timeout?: number\n}\n\nexport type RequestData = { [key: string]: any } | FormData | Document\nexport type RequestBody = string | FormData | Document\nexport type HeaderObject = { [key: string]: string }\n\nexport interface PromiseResolve<T> {\n  (value?: any): any\n  (value?: T): T\n}\n\nexport interface PromiseReject {\n  (reason?: any): any\n}\n\nexport class Client {\n  public static Timeout: number = 0\n  public static ResponseType: XMLHttpRequestResponseType = \"json\"\n\n  public static DefaultHeaders = {\n    Accept: \"application/json\",\n    \"Cache-Control\": \"no-cache\",\n    \"X-Requested-With\": \"XMLHttpRequest\"\n  }\n\n  private xhr: XMLHttpRequest\n  private method: string\n  private url: string\n  private headers: HeaderObject\n  private data: RequestBody = null\n  private query: string\n  private responseType: XMLHttpRequestResponseType = Client.ResponseType\n  private timeout: number = Client.Timeout\n\n  private queryAdded: boolean = false\n\n  constructor(method: string, url: string) {\n    Object.assign(this, {\n      method,\n      url,\n      headers: Object.assign({}, Client.DefaultHeaders),\n      xhr: new XMLHttpRequest()\n    })\n  }\n\n  /**\n   * Sets an object of headers that will be written to the XHR.\n   * { [header: string]: value: string }\n   */\n  setHeaders(headers: HeaderObject): void {\n    Object.assign(this.headers, headers)\n  }\n  addQueryString(query: string): void {\n    if (this.queryAdded) {\n      throw new Error(\"Cannot add query string twice.\")\n    }\n    this.url += \"?\"\n    this.url += query\n    this.queryAdded = true\n  }\n  addQueryObject(query: QueryObject): void {\n    this.addQueryString(encodeQueryObj(query))\n  }\n\n  private setData(data: RequestData): void {\n    if (!data) {\n      return\n    }\n    if (data instanceof FormData || data instanceof Document) {\n      this.data = data\n    }\n    this.data = JSON.stringify(data)\n  }\n  private applyHeaders(): void {\n    for (const header of Object.keys(this.headers)) {\n      if (!this.headers[header]) {\n        continue\n      }\n      this.xhr.setRequestHeader(header, this.headers[header])\n    }\n  }\n  private handleReadyStateChange(resolve: PromiseResolve<Response>, reject: PromiseReject) {\n    if (this.xhr.readyState !== XMLHttpRequest.DONE) {\n      return\n    }\n\n    const response = new Response()\n    response.data = this.xhr.responseType == \"text\" ? this.xhr.responseText : this.xhr.response\n    response.status = this.xhr.status\n    response.statusText = this.xhr.statusText\n    response.headers = parseHeaders(this.xhr.getAllResponseHeaders())\n    response.xhr = this.xhr\n\n    if (this.xhr.status < 200 || this.xhr.status >= 400) {\n      reject(response)\n    }\n\n    resolve(response)\n  }\n  private execute(resolve: PromiseResolve<Response>, reject: PromiseReject) {\n    this.xhr.open(this.method, this.url, Client.Async)\n    this.xhr.responseType = this.responseType\n    this.xhr.timeout = this.timeout\n    this.applyHeaders()\n    this.xhr.onreadystatechange = this.handleReadyStateChange.bind(this, resolve, reject)\n    this.xhr.ontimeout = reject\n    this.xhr.onerror = reject\n    this.xhr.send(this.data)\n  }\n\n  do(): Promise<Response> {\n    return new Promise<Response>(this.execute.bind(this))\n  }\n\n  static make(method: string, url: string, options: RequestOptions = {}): Client {\n    const client = new Client(method, url)\n    if (options.query) {\n      client.addQueryObject(options.query)\n    }\n    if (method != \"GET\" && options.data) {\n      client.setData(options.data)\n    }\n    if (options.responseType) {\n      client.responseType = options.responseType\n    }\n    if (options.headers) {\n      client.setHeaders(options.headers)\n    }\n    if (options.timeout) {\n      client.timeout = options.timeout\n    }\n    return client\n  }\n\n  public static get(url: string, query?: QueryObject): Promise<Response> {\n    return Client.make(\"GET\", url, { query }).do()\n  }\n  public static post(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n    options.data = data\n    return Client.make(\"POST\", url, options).do()\n  }\n  public static put(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n    options.data = data\n    return Client.make(\"PUT\", url, options).do()\n  }\n  public static patch(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n    options.data = data\n    return Client.make(\"PATCH\", url, options).do()\n  }\n  public static delete(url: string, query?: QueryObject): Promise<Response> {\n    return Client.make(\"DELETE\", url, { query }).do()\n  }\n\n  public static setResponseType(type: XMLHttpRequestResponseType): void {\n    Client.ResponseType = type\n  }\n\n  static get Async() {\n    return true\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr/client.ts","import { Client } from \"./xhr/client\"\n\ntype Dictionary<T> = { [key: string]: T }\n\nconst compatChecks: Dictionary<boolean> = {\n  XMLHttpRequest: \"XMLHttpRequest\" in window,\n  Promise: \"Promise\" in window,\n  FormData: \"FormData\" in window,\n  \"Array.isArray\": typeof Array.isArray == \"function\",\n  \"Object.assign\": typeof Object.assign == \"function\",\n  \"Object.keys\": typeof Object.keys == \"function\"\n}\n\nfor (const key in compatChecks) {\n  if (!compatChecks.hasOwnProperty(key) || compatChecks[key]) {\n    continue\n  }\n  const err = new Error(`[browser-http-client] Required ${key} is not available in the browser`)\n  if (typeof window.onerror == \"function\") {\n    throw err\n  } else {\n    console.error(err)\n  }\n}\n\n// Export sub-modules for ESM\nexport { Client }\n\n// Export a wrapper object for browser.\nconst Http = { Client }\nexport default Http\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"sourceRoot":""}