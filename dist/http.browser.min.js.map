{"version":3,"sources":["webpack:///webpack/bootstrap 57ece587ec3c891ccaa1","webpack:///./src/xhr/headers.ts","webpack:///./src/encoding/url.ts","webpack:///./src/xhr/contentType.ts","webpack:///./src/xhr/client.ts","webpack:///./src/index.ts"],"names":[],"mappings":"uBACA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,KAIA,2CAGA,aAGA,OACA,OAIA,IAzBA,eA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,2CCrB+F,gBAK9F,KAMI,IAAe,GANJ,GACH,EACF,IACH,EAAS,OACR,EAAS,SAEqB,EAAnB,EAAO,EAAM,MAAM,MAAnB,IAAmB,WAalC,UAZF,EAAO,EAAQ,QAAK,KAClB,EAAO,EACF,OAAM,KACE,UAAK,IACJ,UAAK,IACP,cACZ,EAAO,EACF,OAAE,EAAK,GACC,UAAK,IACJ,UAAK,MAGL,EAAV,KAAoC,eAE1C,OACE,GAAsB,YAAlB,KACF,CAAM,MAAQ,QAAgB,QAGjC,SAAyB,KAAU,QAErC,QAAC,CAEE,GAA2B,cAAE,CACpB,MAAc,OAE1B,QAAC,CAIH,OAAC,CC9E4C,aAC5C,CAMI,IAAM,GANM,MACd,EAAqB,mBACP,SACF,SACA,WAEa,EAAjB,EAAM,OAAW,QAAjB,IAAiB,WAEvB,GAFE,OACF,EAAU,KACe,UAAd,YAGb,YAEE,GAAM,MAAc,WAAE,CACpB,IAAM,MAAG,MAAH,IAAG,YAAP,EACF,KAGF,aACM,EAAK,KAAK,KAAQ,MAAI,EAAE,EAC/B,aAGF,QAAC,CAEM,EAAK,KAAK,KAAM,IAAI,EAAI,EAC/B,aAEK,MAAQ,GAAK,KACpB,IClCA,CCuBwC,cACvC,GAAK,GAAS,OAAO,OAAM,MAgB5B,MAdE,GAEE,MACD,EAAK,KAD0B,MAA1B,IAAa,aACP,EAEN,aAAM,EACZ,SAEA,EAAO,OAAM,EAAO,OACpB,EAAW,WAAM,EAAW,WAC5B,EAAQ,QAAS,OAAO,OAAM,MAClB,EAAI,EAAwB,wBAAG,EAAS,UAGrD,kDHtCD,GEKC,GFLkB,EAAwB,CACjC,OACU,iBACG,oBACF,kBACV,QACG,WACH,QACA,QACe,uBACE,yBACN,mBACP,YACM,kBACO,yBACd,WACM,iBAEnB,iBEpBD,CAAuB,YACtB,OAAyB,mBACzB,OAAmB,aACnB,OAAkB,YAClB,OAA0C,oCAC1C,YAAiC,sBACjC,SACD,0BAAC,GAPsB,ICEoB,OAiD3C,iBAkBwD,gBAAnC,KAAc,SAAU,KAAW,MAR/C,KAAG,IAAmB,GAAoB,gBAC1C,KAAO,QAA8B,OAAO,OAAO,OAAO,OAAM,MAAQ,EAAgB,gBACxF,KAAI,KAAoB,KAExB,KAAY,aAAqC,EAAa,aAC9D,KAAO,QAAiB,EAAQ,QAChC,KAEkD,aAAC,CAkH3D,MA7GA,aAAU,WAA6B,YAChC,OAAO,OAAK,KACnB,UAAC,EAID,YAAU,WAA6B,YAClC,KAAQ,QAAS,OAAO,OAAO,OAAO,OAC3C,QAAC,EACD,YAAc,eAAc,YACxB,GAAK,KAAc,WACrB,KAAM,IAAS,OACf,kCACG,KAAI,KAAO,IACX,KAAa,OACb,KACL,aAAC,EACD,YAAc,eAAuB,YAChC,KAAe,eACpB,KAAC,EAEO,YAAO,QAAkB,WAI7B,UAAK,YAAoB,WAAQ,YAAuB,eACtD,KAEJ,aACG,KAAK,KAAO,KAAgB,aAC5B,KAAW,WAAC,CAAgB,eAAa,EAC9C,cAAC,EACO,YAAY,aAApB,WACK,IAAC,GAAY,KAAQ,MACpB,QAAK,KAER,YACG,KAAI,IAAwB,mBAAM,KAExC,WAAC,EACO,YAAsB,uBAAyD,cACnF,GAAK,KAAI,IAAW,aAAmB,eAEzC,MAED,GAAK,GAAc,EAAK,KACrB,MAAsB,GAAjB,MAAI,IAAO,QAAmC,GAArB,OAAI,IAAO,SAE3C,KAGF,KAAC,EACO,YAAO,QAAyD,cACnE,KAAI,IAAK,KAAK,KAAO,OAAM,KAAI,IAAQ,EAAO,OAC9C,KAAI,IAAa,aAAO,KAAa,aACrC,KAAI,IAAQ,QAAO,KAAQ,QAC3B,KAAe,eACf,KAAI,IAAmB,mBAAO,KAAuB,uBAAK,KAAuB,UACjF,KAAI,IAAmB,YACvB,KAAI,IAAiB,UACrB,KAAI,IAAK,KAAK,KACnB,KAAC,EAED,YAAE,GAAF,WACO,MAAC,IAAW,SAAe,KAAQ,QAAK,KAC/C,MAAC,EAEM,EAAI,KAA0D,eAA5B,cAA4B,MACpE,GAAY,GACT,WAgBJ,MAhBY,GAAS,OACb,EAAe,eAAQ,EAE3B,OAAQ,EAAQ,MACZ,EAAQ,QAAQ,EAEpB,MAAQ,EAAgB,eACpB,EAAa,aAAU,EAE3B,cAAQ,EAAW,SACf,EAAW,WAAQ,EAEvB,SAAQ,EAAW,UACf,EAAQ,QAAU,EACxB,UAED,EAEa,EAAG,IAAqC,cAC/C,MAAO,GAAK,KAAW,QAAE,CAAU,UAC1C,IAAC,EACa,EAAI,KAA6D,eAA5B,CAE5C,oBAFwE,MACvE,EAAY,OACN,EAAK,KAAsB,YACzC,IAAC,EACa,EAAG,IAA6D,eAA5B,CAE3C,oBAFuE,MACtE,EAAY,OACN,EAAK,KAAqB,WACxC,IAAC,EACa,EAAK,MAA6D,eAA5B,CAE7C,oBAFyE,MACxE,EAAY,OACN,EAAK,KAAuB,aAC1C,IAAC,EACa,EAAM,OAAqC,cAClD,MAAO,GAAK,KAAc,WAAE,CAAU,UAC7C,IAAC,EAEa,EAAe,gBAAiC,YACvD,EACP,cAAC,EAlIa,EAAO,QAAY,EACnB,EAAY,aAAqC,OACjD,EAAqB,SAErB,EAAc,eAAG,CACxB,OAAa,EAAK,KACN,mBAClB,mBA4HD,sCCvLoC,GAIrC,GAAO,GAAK,GACR,EAAO,KACE,EAA8B,OAAO,OAAM,MAWpD,QATQ,GAAe,eAAmB,kBAAU,QAC5C,EAAQ,QAAY,WAAU,QAC9B,EAAS,SAAa,YAAU,QAChC,EAAiB,iBAAqC,UAAlC,QAAY,OAAQ,QACxC,EAAiB,iBAAqC,UAAlC,QAAa,QAAO,OACxC,EAAe,eAAmC,UAAhC,QAAa,QAAK,KACpC,EAAiB,iBAAqC,UAAlC,QAAa,QAAO,SAKlD,OACE,EAAG,GAAS,OACZ,4EAAuC,UAAtC,QAAa,QAAQ,SAClB,OAAQ,QAAI,EAAQ,QAAc,EAAS,SAAc,EAAW,WAAc,EAShF,mBACS,WADN,CACb","file":"http.browser.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 57ece587ec3c891ccaa1","export type Dictionary<T> = { [key: string]: T }\n\nconst ignoreDupeMap: Dictionary<boolean> = {\n\tage: true,\n\tauthorization: true,\n\t\"content-length\": true,\n\t\"content-type\": true,\n\tetag: true,\n\texpires: true,\n\tfrom: true,\n\thost: true,\n\t\"if-modified-since\": true,\n\t\"if-unmodified-since\": true,\n\t\"last-modified\": true,\n\tlocation: true,\n\t\"max-forwards\": true,\n\t\"proxy-authorization\": true,\n\treferer: true,\n\t\"retry-after\": true,\n\t\"user-agent\": true,\n}\n\n/**\n * Parse headers into the target object.\n *\n * ```\n * const resHeaders =\n * `Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked`\n *\n * parseHeaders(resHeaders)\n * // Output:\n * { date: 'Wed, 27 Aug 2014 08:58:49 GMT',\n *  'content-type': 'application/json',\n *  connection: 'keep-alive',\n *  'transfer-encoding': 'chunked' }\n * ```\n */\nexport function Parse(headers: string, target: { [key: string]: string | string[] | undefined }): void {\n\tif (!headers) {\n\t\treturn\n\t}\n\n\tlet key: string,\n\t\tval: string,\n\t\ti: number,\n\t\tleadSp = /^\\s*/,\n\t\ttrailSp = /\\s*$/\n\n\tfor (const line of headers.split(\"\\n\")) {\n\t\ti = line.indexOf(\":\")\n\t\tkey = line\n\t\t\t.substr(0, i)\n\t\t\t.replace(leadSp, \"\")\n\t\t\t.replace(trailSp, \"\")\n\t\t\t.toLowerCase()\n\t\tval = line\n\t\t\t.substr(i + 1)\n\t\t\t.replace(leadSp, \"\")\n\t\t\t.replace(trailSp, \"\")\n\n\t\t// Skip empty keys and defined items in the ignore list.\n\t\tif (key == \"\" || (target[key] !== undefined && ignoreDupeMap[key])) {\n\t\t\tcontinue\n\t\t}\n\t\tif (key === \"set-cookie\") {\n\t\t\tif (!Array.isArray(target[key])) {\n\t\t\t\ttarget[key] = []\n\t\t\t}\n\t\t\t;(target[key] as string[]).push(val)\n\t\t\tcontinue\n\t\t}\n\n\t\tif (target[key] !== undefined) {\n\t\t\ttarget[key] += \", \" + val\n\t\t\tcontinue\n\t\t}\n\n\t\ttarget[key] = val\n\t}\n}\n\nexport interface HttpHeaders {\n\tAccept?: string\n\t\"Access-Control-Allow-Origin\"?: string\n\t\"Access-Control-Allow-Credentials\"?: string\n\t\"Access-Control-Expose-Headers\"?: string\n\t\"Access-Control-Max-Age\"?: string\n\t\"Access-Control-Allow-Methods\"?: string\n\t\"Access-Control-Allow-Headers\"?: string\n\t\"Accept-Patch\"?: string\n\t\"Accept-Ranges\"?: string\n\tAge?: string\n\tAllow?: string\n\t\"Alt-Svc\"?: string\n\t\"Cache-Control\"?: string\n\tconnection?: string\n\t\"Content-Disposition\"?: string\n\t\"Content-Encoding\"?: string\n\t\"Content-Language\"?: string\n\t\"Content-Length\"?: string\n\t\"Content-Location\"?: string\n\t\"Content-Range\"?: string\n\t\"Content-Type\"?: string\n\tDate?: string\n\tExpires?: string\n\tHost?: string\n\t\"Last-Modified\"?: string\n\tLocation?: string\n\tPragma?: string\n\t\"Proxy-Authenticate\"?: string\n\t\"Public-Key-Pins\"?: string\n\t\"Retry-After\"?: string\n\t\"Set-Cookie\"?: string\n\t\"Strict-Transport-Security\"?: string\n\tTrailer?: string\n\t\"Transfer-Encoding\"?: string\n\tTk?: string\n\tUpgrade?: string\n\tVary?: string\n\tVia?: string\n\tWarning?: string\n\t\"Www-Authenticate\"?: string\n\t[header: string]: string | undefined\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr/headers.ts","export type Primitives = string | number | boolean | null\nexport type PrimitiveArray = string[] | number[] | boolean[] | null[]\nexport type QueryObject = { [index: string]: Primitives | PrimitiveArray }\n\nexport function EncodeQuery(data: QueryObject) {\n\tlet encoded = [],\n\t\te = encodeURIComponent,\n\t\tval = undefined,\n\t\tv = undefined,\n\t\tk = undefined\n\n\tfor (k of Object.keys(data)) {\n\t\tval = data[k]\n\t\tif (typeof val == \"function\" || val === undefined) {\n\t\t\t// Break QueryObject key iter for non encodable types.\n\t\t\tcontinue\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tfor (v of val) {\n\t\t\t\tif (v === undefined) {\n\t\t\t\t\t// Break inner array iter.\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tencoded.push(e(k) + \"[]=\" + e(v.toString()))\n\t\t\t}\n\t\t\t// Break QueryObject key iter.\n\t\t\tcontinue\n\t\t}\n\n\t\tencoded.push(e(k) + \"=\" + e(val.toString()))\n\t}\n\n\treturn encoded.join(\"&\")\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/encoding/url.ts","export enum ContentType {\n\tJson = \"application/json\",\n\tText = \"text/plain\",\n\tHtml = \"text/html\",\n\tForm = \"application/x-www-form-urlencoded\",\n\tMultipart = \"multipart/form-data\",\n\tStream = \"application/octet-stream\",\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr/contentType.ts","import * as headers from \"./headers\"\nimport * as url from \"../encoding/url\"\nimport { ContentType } from \"./contentType\"\n\nexport interface RequestOptions {\n\tquery?: url.QueryObject\n\tdata?: RequestData\n\theaders?: headers.HttpHeaders\n\tresponseType?: XMLHttpRequestResponseType\n\ttimeout?: number\n}\n\nexport type RequestData = { [key: string]: any } | FormData | Document\nexport type RequestBody = string | FormData | Document\n\nexport interface Response {\n\tdata: any\n\tstatus: number\n\tstatusText: string\n\theaders: object\n\txhr: XMLHttpRequest\n}\n\nfunction newResponse(xhr: XMLHttpRequest): Response {\n\tlet r = Object.create(null)\n\n\tr.xhr = xhr\n\n\tif (xhr.responseType == \"text\") {\n\t\tr.data = xhr.responseText\n\t} else {\n\t\tr.data = xhr.response\n\t}\n\n\tr.status = xhr.status\n\tr.statusText = xhr.statusText\n\tr.headers = Object.create(null)\n\theaders.Parse(xhr.getAllResponseHeaders(), r.headers)\n\n\treturn r\n}\n\nexport interface PromiseResolve<T> {\n\t(value?: any): any\n\t(value?: T): T\n}\n\nexport interface PromiseReject {\n\t(reason?: any): any\n}\n\nexport class Client {\n\tpublic static Timeout: number = 0\n\tpublic static ResponseType: XMLHttpRequestResponseType = \"json\"\n\tpublic static Async: boolean = true\n\n\tpublic static DefaultHeaders = {\n\t\tAccept: ContentType.Json,\n\t\t\"X-Requested-With\": \"XMLHttpRequest\",\n\t}\n\n\tprivate xhr: XMLHttpRequest = new XMLHttpRequest()\n\tprivate headers: headers.HttpHeaders = Object.assign(Object.create(null), Client.DefaultHeaders)\n\tprivate data: RequestBody = null\n\tprivate query: string\n\tprivate responseType: XMLHttpRequestResponseType = Client.ResponseType\n\tprivate timeout: number = Client.Timeout\n\tprivate queryAdded: boolean = false\n\n\tconstructor(private method: string, private url: string) {}\n\n\t/**\n\t * Adds an object of headers via `Object.assign` that will be written to the XHR.\n\t */\n\taddHeaders(headers: headers.HttpHeaders): void {\n\t\tObject.assign(this.headers, headers)\n\t}\n\t/**\n\t * Sets a new object of headers that will be written to the XHR.\n\t */\n\tsetHeaders(headers: headers.HttpHeaders): void {\n\t\tthis.headers = Object.assign(Object.create(null), headers)\n\t}\n\taddQueryString(query: string): void {\n\t\tif (this.queryAdded) {\n\t\t\tthrow new Error(\"Cannot add query string twice.\")\n\t\t}\n\t\tthis.url += \"?\"\n\t\tthis.url += query\n\t\tthis.queryAdded = true\n\t}\n\taddQueryObject(query: url.QueryObject): void {\n\t\tthis.addQueryString(url.EncodeQuery(query))\n\t}\n\n\tprivate setData(data: RequestData): void {\n\t\tif (!data) {\n\t\t\treturn\n\t\t}\n\t\tif (data instanceof FormData || data instanceof Document) {\n\t\t\tthis.data = data\n\t\t\treturn\n\t\t}\n\t\tthis.data = JSON.stringify(data)\n\t\tthis.addHeaders({ \"Content-Type\": ContentType.Json })\n\t}\n\tprivate applyHeaders(): void {\n\t\tfor (const header in this.headers) {\n\t\t\tif (!this.headers[header]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis.xhr.setRequestHeader(header, this.headers[header])\n\t\t}\n\t}\n\tprivate handleReadyStateChange(resolve: PromiseResolve<Response>, reject: PromiseReject) {\n\t\tif (this.xhr.readyState !== XMLHttpRequest.DONE) {\n\t\t\treturn\n\t\t}\n\n\t\tlet r = newResponse(this.xhr)\n\t\tif (this.xhr.status < 200 || this.xhr.status >= 400) {\n\t\t\treject(r)\n\t\t}\n\n\t\tresolve(r)\n\t}\n\tprivate execute(resolve: PromiseResolve<Response>, reject: PromiseReject) {\n\t\tthis.xhr.open(this.method, this.url, Client.Async)\n\t\tthis.xhr.responseType = this.responseType\n\t\tthis.xhr.timeout = this.timeout\n\t\tthis.applyHeaders()\n\t\tthis.xhr.onreadystatechange = this.handleReadyStateChange.bind(this, resolve, reject)\n\t\tthis.xhr.ontimeout = reject\n\t\tthis.xhr.onerror = reject\n\t\tthis.xhr.send(this.data)\n\t}\n\n\tdo(): Promise<Response> {\n\t\treturn new Promise<Response>(this.execute.bind(this))\n\t}\n\n\tstatic make(method: string, url: string, options: RequestOptions = {}): Client {\n\t\tconst client = new Client(method, url)\n\t\tif (options.query) {\n\t\t\tclient.addQueryObject(options.query)\n\t\t}\n\t\tif (options.data) {\n\t\t\tclient.setData(options.data)\n\t\t}\n\t\tif (options.responseType) {\n\t\t\tclient.responseType = options.responseType\n\t\t}\n\t\tif (options.headers) {\n\t\t\tclient.setHeaders(options.headers)\n\t\t}\n\t\tif (options.timeout) {\n\t\t\tclient.timeout = options.timeout\n\t\t}\n\t\treturn client\n\t}\n\n\tpublic static get(url: string, query?: url.QueryObject): Promise<Response> {\n\t\treturn Client.make(\"GET\", url, { query }).do()\n\t}\n\tpublic static post(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n\t\toptions.data = data\n\t\treturn Client.make(\"POST\", url, options).do()\n\t}\n\tpublic static put(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n\t\toptions.data = data\n\t\treturn Client.make(\"PUT\", url, options).do()\n\t}\n\tpublic static patch(url: string, data: RequestData, options: RequestOptions = {}): Promise<Response> {\n\t\toptions.data = data\n\t\treturn Client.make(\"PATCH\", url, options).do()\n\t}\n\tpublic static delete(url: string, query?: url.QueryObject): Promise<Response> {\n\t\treturn Client.make(\"DELETE\", url, { query }).do()\n\t}\n\n\tpublic static setResponseType(type: XMLHttpRequestResponseType): void {\n\t\tClient.ResponseType = type\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr/client.ts","import { Client } from \"./xhr/client\"\n\ntype Dictionary<T> = { [key: string]: T }\n\nlet key = \"\",\n\terr = null,\n\tcompatChecks: Dictionary<boolean> = Object.create(null)\n\ncompatChecks.XMLHttpRequest = \"XMLHttpRequest\" in window\ncompatChecks.Promise = \"Promise\" in window\ncompatChecks.FormData = \"FormData\" in window\ncompatChecks[\"Array.isArray\"] = typeof Array.isArray == \"function\"\ncompatChecks[\"Object.assign\"] = typeof Object.assign == \"function\"\ncompatChecks[\"Object.keys\"] = typeof Object.keys == \"function\"\ncompatChecks[\"Object.create\"] = typeof Object.create == \"function\"\n\nfor (key in compatChecks) {\n\tif (compatChecks[key]) {\n\t\tcontinue\n\t}\n\terr = new Error(`[browser-http-client] A required API is not available in the browser: ${key}`)\n\tif (typeof window.onerror == \"function\") {\n\t\twindow.onerror(err.message, (err as any).fileName, (err as any).lineNumber, (err as any).columnNumber, err)\n\t}\n\tconsole.error(err)\n}\n\n// Export sub-modules for ESM\nexport { Client }\n\n// Export a wrapper object for browser.\nconst Http = { Client }\nexport default Http\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"sourceRoot":""}